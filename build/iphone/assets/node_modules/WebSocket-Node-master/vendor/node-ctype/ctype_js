function ctReadUint8(e,t,r){var o=mod_ctio.ruint8(t,e,r);return{value:o,size:1}}function ctReadUint16(e,t,r){var o=mod_ctio.ruint16(t,e,r);return{value:o,size:2}}function ctReadUint32(e,t,r){var o=mod_ctio.ruint32(t,e,r);return{value:o,size:4}}function ctReadSint8(e,t,r){var o=mod_ctio.rsint8(t,e,r);return{value:o,size:1}}function ctReadSint16(e,t,r){var o=mod_ctio.rsint16(t,e,r);return{value:o,size:2}}function ctReadSint32(e,t,r){var o=mod_ctio.rsint32(t,e,r);return{value:o,size:4}}function ctReadFloat(e,t,r){var o=mod_ctio.rfloat(t,e,r);return{value:o,size:4}}function ctReadDouble(e,t,r){var o=mod_ctio.rdouble(t,e,r);return{value:o,size:8}}function ctReadChar(e,t,r){var o=new Buffer(1);return o[0]=mod_ctio.ruint8(t,e,r),{value:o,size:1}}function ctReadCharArray(e,t,r,o){var i,n=new Buffer(e);for(i=0;e>i;i++)n[i]=mod_ctio.ruint8(r,t,o+i);return{value:n,size:e}}function ctWriteUint8(e,t,r,o){return mod_ctio.wuint8(e,t,r,o),1}function ctWriteUint16(e,t,r,o){return mod_ctio.wuint16(e,t,r,o),2}function ctWriteUint32(e,t,r,o){return mod_ctio.wuint32(e,t,r,o),4}function ctWriteSint8(e,t,r,o){return mod_ctio.wsint8(e,t,r,o),1}function ctWriteSint16(e,t,r,o){return mod_ctio.wsint16(e,t,r,o),2}function ctWriteSint32(e,t,r,o){return mod_ctio.wsint32(e,t,r,o),4}function ctWriteFloat(e,t,r,o){return mod_ctio.wfloat(e,t,r,o),4}function ctWriteDouble(e,t,r,o){return mod_ctio.wdouble(e,t,r,o),8}function ctWriteChar(e,t,r,o){if(!(e instanceof Buffer))throw Error("Input must be a buffer");return mod_ctio.ruint8(e[0],t,r,o),1}function ctWriteCharArray(e,t,r,o,i){var n;if(!(e instanceof Buffer))throw Error("Input must be a buffer");if(e.length>t)throw Error("value length greater than array length");for(n=0;e.length>n&&t>n;n++)mod_ctio.wuint8(e[n],r,o,i+n);for(;t>n;n++)mod_ctio.wuint8(0,r,i+n);return t}function ctGetBasicTypes(){var e,t={};for(e in deftypes)t[e]=deftypes[e];return t}function ctParseType(e){var t,r,o,i;if("string"!=typeof e)throw Error("type must be a Javascript string");if(r=e.lastIndexOf("]"),-1==r){if(-1!=e.lastIndexOf("["))throw Error("found invalid type with '[' but no corresponding ']'");return{type:e}}if(t=e.lastIndexOf("["),-1==t)throw Error("found invalid type with ']' but no corresponding '['");if(t>=r)throw Error("malformed type, ']' appears before '['");return o=e.substring(0,t),i=e.substring(t+1,r),{type:o,len:i}}function ctCheckReq(e,t,r){var o,i,n,s,a,c,u={};if(!(e instanceof Array))throw Error("definition is not an array");if(0===e.length)throw Error("definition must have at least one element");for(o=0;e.length>o;o++){if(n=e[o],!(n instanceof Object))throw Error("definition must be an array ofobjects");if(s=Object.keys(n),1!=s.length)throw Error("definition entry must only have one key");if(s[0]in u)throw Error("Specified name already specified: "+s[0]);if(!("type"in n[s[0]]))throw Error("missing required type definition");for(a=ctParseType(n[s[0]].type);void 0!==a.len;){if(isNaN(parseInt(a.len,10))&&(c=!1,!(a.len in u)))throw Error("Given an array length without a matching type");a=ctParseType(a.type)}if(!(a.type in t))throw Error("type not found or typdefed: "+a.type);if(void 0!==r)for(i=0;r.length>i;i++)if(!(r[i]in n[s[0]]))throw Error("Missing required field: "+r[i]);u[s[0]]=!0}}function CTypeParser(e){if(!e)throw Error("missing required argument");if(!("endian"in e))throw Error("missing required endian value");if("big"!=e.endian&&"little"!=e.endian)throw Error("Invalid endian type");this.endian=e.endian,this.types=ctGetBasicTypes()}function ctResolveArray(e,t){for(var r="",o=ctParseType(e);void 0!==o.len;){if(isNaN(parseInt(o.len,10))){if("number"!=typeof t[o.len])throw Error("cannot sawp in non-number for array value");r="["+t[o.len]+"]"+r}else r="["+o.len+"]"+r;o=ctParseType(o.type)}return r=o.type+r}function toAbs64(e){if(void 0===e)throw Error("missing required arg: value");if(!(e instanceof Array))throw Error("value must be an array");if(2!=e.length)throw Error("value must be an array of length 2");if(e[0]>=1048576)throw Error("value would become approximated");return e[0]*Math.pow(2,32)+e[1]}function toApprox64(e){if(void 0===e)throw Error("missing required arg: value");if(!(e instanceof Array))throw Error("value must be an array");if(2!=e.length)throw Error("value must be an array of length 2");return Math.pow(2,32)*e[0]+e[1]}var mod_ctio=require("./ctio.js"),ASSERT=require("assert"),deftypes={uint8_t:{read:ctReadUint8,write:ctWriteSint8},uint16_t:{read:ctReadUint16,write:ctWriteSint16},uint32_t:{read:ctReadUint32,write:ctWriteSint32},int8_t:{read:ctReadSint8,write:ctWriteSint8},int16_t:{read:ctReadSint16,write:ctWriteSint16},int32_t:{read:ctReadSint32,write:ctWriteSint32},"float":{read:ctReadFloat,write:ctWriteFloat},"double":{read:ctReadDouble,write:ctWriteDouble},"char":{read:ctReadChar,write:ctWriteChar},"char[]":{read:ctReadCharArray,write:ctWriteCharArray}};CTypeParser.prototype.setEndian=function(e){if("big"!=e||"little"!=e)throw Error("invalid endian type, must be big or  little");this.endian=e},CTypeParser.prototype.getEndian=function(){return this.endian},CTypeParser.prototype.typedef=function(e,t){var r;if(void 0===e)throw new(Error("missing required typedef argument: name"));if(void 0===t)throw new(Error("missing required typedef argument: value"));if("string"!=typeof e)throw new(Error("the name of a type must be a string"));if(r=ctParseType(e),void 0!==r.len)throw Error("Cannot have an array in the typedef name");if(e in this.types)throw Error("typedef name already present: "+e);if("string"!=typeof t&&!(t instanceof Array))throw Error("typedef value must either be a string or struct");if("string"==typeof t){if(r=ctParseType(t),void 0!==r.len&&isNaN(parseInt(r.len,10)))throw new(Error("typedef value must use fixed size array when outside of a struct"));this.types[e]=t}else ctCheckReq(t,this.types),this.types[e]=t},CTypeParser.prototype.lstypes=function(){var e,t={};for(e in this.types)e in deftypes||(t[e]=this.types[e]);return t},CTypeParser.prototype.resolveTypedef=function(e,t,r,o,i){var n;if(ASSERT.ok(e in this.types),console.log(e+":"+this.types[e]),"string"==typeof this.types[e]){if(n=ctParseType(this.types[e]),"read"==t)return this.readEntry(n,r,o);if("write"==t)return this.writeEntry(i,n,r,o);throw Error("invalid dispatch type to resolveTypedef")}if("read"==t)return this.readStruct(this.types[e],r,o);if("write"==t)return this.readStruct(i,this.types[e],r,o);throw Error("invalid dispatch type to resolveTypedef")},CTypeParser.prototype.readEntry=function(e,t,r){var o,i;if(void 0!==e.len){if(i=parseInt(e.len,10),isNaN(i))throw Error("somehow got a non-numeric length");o="char"==e.type?deftypes["char[]"].read(i,this.endian,t,r):this.readArray(e.type,i,t,r)}else o=e.type in deftypes?deftypes[e.type].read(this.endian,t,r):this.resolveTypedef(e.type,"read",t,r);return o},CTypeParser.prototype.readArray=function(e,t,r,o){var i,n,s,a=o,c=Array(t);for(s=ctParseType(e),i=0;t>i;i++)n=this.readEntry(s,r,o),o+=n.size,c[i]=n.value;return{value:c,size:o-a}},CTypeParser.prototype.readStruct=function(e,t,r){var o,i,n,s,a,c=r,u={};for(i=0;e.length>i;i++)a=Object.keys(e[i])[0],s=e[i][a],n=ctParseType(ctResolveArray(s.type,u)),"offset"in s&&(r=c+s.offset),o=this.readEntry(n,t,r),r+=o.size,u[a]=o.value;return{values:u,size:r-c}},CTypeParser.prototype.readData=function(e,t,r){if(void 0===e)throw Error("missing definition for what we should beparsing");if(void 0===t)throw Error("missing buffer for what we should beparsing");if(void 0===r)throw Error("missing offset for what we should beparsing");return ctCheckReq(e,this.types),this.readStruct(e,t,r).values},CTypeParser.prototype.writeArray=function(e,t,r,o,i){var n,s,a=i;if(!(e instanceof Array))throw Error("asked to write an array, but value is not an array");if(e.length!=r)throw Error("asked to write array of length "+r+" but that does not match value length: "+e.length);for(s=ctParseType(t),n=0;r>n;n++)i+=this.writeEntry(e[n],s,o,i);return i-a},CTypeParser.prototype.writeEntry=function(e,t,r,o){var i,n;if(void 0!==t.len){if(i=parseInt(t.len,10),isNaN(i))throw Error("somehow got a non-numeric length");n="char"==t.type?deftypes["char[]"].write(e,i,this.endian,r,o):this.writeArray(e,t.type,i,r,o)}else n=t.type in deftypes?deftypes[t.type].write(e,this.endian,r,o):this.resolveTypedef(t.type,"write",r,o,e);return n},CTypeParser.prototype.writeStruct=function(e,t,r){var o,i,n,s,a=r,c={};for(o=0;e.length>o;o++)s=Object.keys(e[o])[0],i=e[o][s],n=ctParseType(ctResolveArray(i.type,c)),"offset"in i&&(r=a+i.offset),r+=this.writeEntry(i.value,n,t,r),c[s]=i.value},CTypeParser.prototype.writeData=function(e,t,r){if(void 0===e)throw Error("missing definition for what we should beparsing");if(void 0===t)throw Error("missing buffer for what we should beparsing");if(void 0===r)throw Error("missing offset for what we should beparsing");ctCheckReq(e,this.types,["value"]),this.writeStruct(e,t,r)},exports.Parser=CTypeParser,exports.ruint8=mod_ctio.ruint8,exports.ruint16=mod_ctio.ruint16,exports.ruint32=mod_ctio.ruint32,exports.ruint64=mod_ctio.ruint64,exports.wuint8=mod_ctio.wuint8,exports.wuint16=mod_ctio.wuint16,exports.wuint32=mod_ctio.wuint32,exports.wuint64=mod_ctio.wuint64,exports.rsint8=mod_ctio.rsint8,exports.rsint16=mod_ctio.rsint16,exports.rsint32=mod_ctio.rsint32,exports.rsint64=mod_ctio.rsint64,exports.wsint8=mod_ctio.wsint8,exports.wsint16=mod_ctio.wsint16,exports.wsint32=mod_ctio.wsint32,exports.wsint64=mod_ctio.wsint64,exports.rfloat=mod_ctio.rfloat,exports.rdouble=mod_ctio.rdouble,exports.wfloat=mod_ctio.wfloat,exports.wdouble=mod_ctio.wdouble;